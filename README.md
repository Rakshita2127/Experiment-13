# Experiment-13
## Program 1
### Aim: 
To implement Function Overloading. 
### Software used: 
Visual Studio Code
### Theory:
Multiple functions with the same name can coexist in the same scope in C++ thanks to function overloading, provided that their parameter lists differ (either in type, number, or both). Depending on the kind or quantity of arguments supplied during the function call, the compiler distinguishes between the functions. By enabling a single function name to carry out comparable tasks with various input types, function overloading improves readability and usability.
Functions must differ in parameter type, number of parameters, or both.
The return type alone cannot be used to distinguish overloaded functions.
### Output:
<img width="695" alt="image" src="https://github.com/user-attachments/assets/e4d3a80d-e7ac-4dd0-a2f5-7e9095633c48">

### Conclusion:
We learned how to implement function overloading in C++. 

## Program 2
### Aim: 
To implement Operator overloading. 
### Software used: 
Visual Studio Code
### Theory:
Programmers can modify the behavior of standard operators (such as +, -, *, ==, etc.) for user-defined types (classes or structs) in C++ by using operator overloading. You can allow class objects to make meaningful use of operators by overloading them. To add two complex numbers, for example, you can specify how the + operator functions for a custom Complex number class.
Not every operator (such as ::, sizeof,?:) can be overloaded.
Depending on the class, the overloaded operator can have various implementations and acts like a function.
Operator precedence and associativity are unaffected by operator overloading.

### Output:
<img width="703" alt="image" src="https://github.com/user-attachments/assets/31b18a89-6fb4-465a-91a2-b420cb9bfd4a">

### Conclusion:
We learned how to implement operator overloading in C++. 
